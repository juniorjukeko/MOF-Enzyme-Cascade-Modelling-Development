# solve.py
import pyomo.environ as pyo
import pyomo.dae as dae

def solve_model(model):
    """
    Discretize and solve the reactor kinetics model.
    
    Parameters:
    model: Pyomo model to solve
    
    Returns:
    model: Solved model
    results: Solver results
    """
    print("Discretizing model...")
    
    # Discretize time and space (x) variables
    discretizer = pyo.TransformationFactory('dae.collocation')
    discretizer.apply_to(model, wrt=model.time, nfe=40, ncp=2)  # Total discretization points = nfe*ncp
    discretizer.apply_to(model, wrt=model.x, nfe=20, ncp=3)
    
    print("Discretization completed.")
    print("Solving model with IPOPT...")
    
    # Solve model
    solver = pyo.SolverFactory('ipopt')
    results = solver.solve(model, tee=True)
    
    print(f"Solver termination condition: {results.solver.termination_condition}")
    print(f"Solver status: {results.solver.status}")
    
    return model, results

def solve_model_robust(model, max_iter=5000, tol=1e-6, verbose=False):
    """
    Discretize and solve the Pyomo DAE model using IPOPT with robust solver settings.

    Parameters
    ----------
    model : pyo.ConcreteModel
        The Pyomo model containing DAE and algebraic constraints.
    max_iter : int, optional
        Maximum number of solver iterations (default: 5000).
    tol : float, optional
        Solver tolerance for convergence (default: 1e-6).
    verbose : bool, optional
        If True, print progress messages and solver logs (default: True).

    Returns
    -------
    model : pyo.ConcreteModel
        The solved model with updated variable values.
    results : SolverResults
        The IPOPT solver result object containing status and termination info.
    """
    if verbose:
        print("Discretizing model...")

    # Discretize time and space
    discretizer = pyo.TransformationFactory('dae.collocation')
    discretizer.apply_to(model, wrt=model.time, nfe=60, ncp=2)
    discretizer.apply_to(model, wrt=model.x, nfe=20, ncp=3)

    if verbose:
        print("Discretization completed.")
        print("Solving model with IPOPT (robust settings)...")

    # Configure IPOPT solver
    solver = pyo.SolverFactory('ipopt')
    solver_options = {
        'max_iter': max_iter,
        'tol': tol,
        'constr_viol_tol': tol,
        'acceptable_tol': 1e-4,
        'acceptable_iter': 5,
        'mu_strategy': 'adaptive',
        'mu_init': 1e-5,
        'bound_relax_factor': 1e-8,
        'honor_original_bounds': 'no',
        'nlp_scaling_method': 'gradient-based',
        'obj_scaling_factor': 1.0,
        'print_level': 5 if verbose else 0,
        'linear_solver': 'mumps'
    }
    solver_options['linear_solver'] = 'mumps'
    for k, v in solver_options.items():
        solver.options[k] = v

    try:
        results = solver.solve(model, tee=verbose)
    except Exception as e:
        if verbose:
            print(f"First solve attempt failed: {e}")
            print("Retrying with more relaxed settings...")

        solver_options.update({
            'max_iter': 5000,
            'tol': 1e-4,
            'mu_init': 1e-3,
            'bound_relax_factor': 1e-6,
        })
        for k, v in solver_options.items():
            solver.options[k] = v

        results = solver.solve(model, tee=verbose)

    if verbose:
        print(f"Solver termination condition: {results.solver.termination_condition}")
        print(f"Solver status: {results.solver.status}")

    return model, results
